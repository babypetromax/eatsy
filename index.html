<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>เมนูอาหาร</title> <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles --- */
        :root {
            /* Theme Colors */
            --color-darkest: #333D29;
            --color-dark-green: #414833;
            --color-medium-green: #656D4A;
            --color-light-green: #A4AC86; /* Used for Order Button */
            --color-lightest-green: #C2C5AA;
            --color-light-beige: #B6AD90; /* Used for Cart Header */
            --color-medium-beige: #A68A64; /* Color for Price and Checkout Button */
            --color-text-primary: #343A40;
            --color-text-secondary: #6C757D;
            --color-background: #F8F9FA;
            --color-white: #FFFFFF;
            --color-white-transparent: rgba(255, 255, 255, 0.9); /* Cart background */
            --color-footer-transparent: rgba(248, 249, 250, 0.9); /* Cart footer background */
            --color-border: #dee2e6;
            --color-danger: #dc3545; /* Red for remove/delete actions */
            --color-info: #17a2b8; /* Info color for prompts */
            --color-modal-bg: rgba(0, 0, 0, 0.6);
            /* Transitions */
            --transition-speed-fast: 0.2s;
            --transition-speed-medium: 0.3s;
            --transition-speed-slow: 0.5s;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Sarabun', 'Inter', sans-serif;
            margin: 0; padding: 0;
            background-color: var(--color-background); color: var(--color-text-primary);
            overscroll-behavior-y: contain;
            padding-bottom: 225px; /* Adjusted space for floating icons */
        }
        body::-webkit-scrollbar { display: none; }
        body { -ms-overflow-style: none; scrollbar-width: none; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 10px; }

        /* --- Top Section --- */
        .top-section {
            width: calc(100% + 20px); margin-bottom: 15px; position: relative;
            margin-left: -10px; margin-right: -10px;
        }
        .image-container {
            width: 100%; aspect-ratio: 5 / 4; overflow: hidden;
            background-color: #e0e0e0; position: relative; cursor: grab;
        }
        .image-container:active { cursor: grabbing; }
        .main-food-image {
            width: 100%; height: 100%; object-fit: cover; object-position: center;
            display: block;
        }

        /* --- Swipe Animation Classes --- */
        @keyframes slideOutLeft { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .image-container.slide-out-left .main-food-image { animation: slideOutLeft var(--transition-speed-medium) ease-out forwards; }
        .image-container.slide-in-right .main-food-image { animation: slideInRight var(--transition-speed-medium) ease-out forwards; }
        .image-container.slide-out-right .main-food-image { animation: slideOutRight var(--transition-speed-medium) ease-out forwards; }
        .image-container.slide-in-left .main-food-image { animation: slideInLeft var(--transition-speed-medium) ease-out forwards; }

        /* --- Menu Details --- */
        #menu-details {
            padding: 15px 10px; background-color: var(--color-white);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); display: none;
             margin-left: 10px; margin-right: 10px;
             width: calc(100% - 20px); border-radius: 0 0 10px 10px;
        }
        .menu-name-container { margin-bottom: 5px; }
        #menu-name { font-size: 28px; font-weight: bold; text-transform: uppercase; margin: 0; color: var(--color-darkest); line-height: 1.2; }
        #menu-description { font-size: 14px; margin: 0 0 10px 0; color: var(--color-medium-green); line-height: 1.5; }
        #menu-price { font-size: 18px; font-weight: bold; margin: 0; color: var(--color-medium-beige); display: flex; align-items: center; flex-wrap: wrap; gap: 5px 0; }
        .price-item { display: inline-flex; align-items: center; margin-right: 10px; }
        .price-label { font-size: 0.8em; font-weight: normal; color: var(--color-text-secondary); margin-right: 4px; }
        .price-value { margin-right: 5px; }
        .add-to-cart-button {
            background-color: var(--color-medium-green); color: var(--color-white); border: none; border-radius: 50%;
            width: 24px; height: 24px; font-size: 16px; font-weight: bold; line-height: 24px; text-align: center;
            cursor: pointer; transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
            padding: 0; flex-shrink: 0;
        }
        .add-to-cart-button:hover { background-color: var(--color-dark-green); transform: scale(1.1); }
        .price-separator { margin: 0 8px; font-weight: normal; color: #adb5bd; }
        .hidden { display: none !important; }

        /* --- Category Bar --- */
        .category-bar {
            width: 100%; overflow-x: auto; overflow-y: hidden; white-space: nowrap; background-color: var(--color-white);
            padding: 12px 5px; display: flex; align-items: center; flex-shrink: 0; box-sizing: border-box;
            border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            -ms-overflow-style: none; scrollbar-width: none;
        }
        .category-bar::-webkit-scrollbar { display: none; }
        .category-item {
            display: flex; flex-direction: column; align-items: center; padding: 8px 15px; margin: 0 5px;
            background-color: transparent; color: var(--color-text-secondary); border-radius: 8px; cursor: pointer;
            flex-shrink: 0; font-size: 0.85em; text-align: center;
            transition: background-color var(--transition-speed-medium) ease, color var(--transition-speed-medium) ease, transform var(--transition-speed-fast) ease;
            border-bottom: 2px solid transparent;
        }
        .category-item.selected { color: var(--color-dark-green); font-weight: bold; border-bottom: 2px solid var(--color-medium-green); background-color: #E9ECEF; }
        .category-item i { font-size: 1.4em; margin-bottom: 4px; }
        .category-item span { font-size: 0.75em; white-space: normal; line-height: 1.2; }
        .category-item:hover:not(.selected) { color: #495057; background-color: #F1F3F4; transform: translateY(-2px); }

        /* --- Pinterest-Style Menu Grid --- */
        .bottom-menu {
            width: 100%; padding-top: 10px; column-count: 2;
            column-gap: 10px; contain: layout paint;
        }
        .menu-item {
            display: inline-block; width: 100%; margin-bottom: 10px; border-radius: 10px; overflow: hidden;
            cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform var(--transition-speed-fast) ease-in-out, box-shadow var(--transition-speed-fast) ease-in-out, filter var(--transition-speed-fast) ease-in-out;
            break-inside: avoid;
        }
        .menu-item:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 4px 8px rgba(0,0,0,0.15); filter: brightness(1.05); }
        .menu-item img { width: 100%; height: auto; display: block; }

        /* --- Floating Icons --- */
        .floating-icon {
             position: fixed; right: 20px;
             background-color: var(--color-medium-green); color: var(--color-white);
             width: 55px; height: 55px; border-radius: 50%; display: flex; justify-content: center; align-items: center;
             cursor: pointer; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
             transition: background-color var(--transition-speed-medium) ease, transform var(--transition-speed-fast) ease;
             z-index: 1000;
             border: none; /* Ensure buttons don't have default borders */
             padding: 0; /* Ensure buttons don't have default padding */
         }
         .floating-icon:hover { background-color: var(--color-dark-green); transform: scale(1.1); }
         .floating-icon .badge {
             position: absolute; top: -5px; right: -5px; background-color: var(--color-danger); color: white;
             border-radius: 50%; width: 22px; height: 22px; font-size: 12px; font-weight: bold;
             display: flex; justify-content: center; align-items: center; line-height: 22px; border: 1px solid white;
             transition: transform var(--transition-speed-fast) ease;
         }
         .floating-icon.updated .badge { transform: scale(1.3); }
         /* Ensure disabled state is visually clear */
        .floating-icon:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: var(--color-medium-green); /* Keep base color or slightly greyed out */
            transform: none; /* Disable hover transform */
        }
        .floating-icon:disabled:hover {
             background-color: var(--color-medium-green); /* Prevent hover color change when disabled */
             transform: none;
         }


         #call-staff-icon-container { bottom: 150px; z-index: 1002; font-size: 22px; }
         #my-food-icon-container { bottom: 85px; z-index: 1001; font-size: 22px; }
         #cart-icon-container { bottom: 20px; z-index: 1000; font-size: 24px; }

        /* Spinner for loading state on icons */
         .floating-icon .fa-spinner { font-size: 24px; }

        /* --- Popups (Cart & My Food) --- */
        .popup-container {
            position: fixed; right: 20px; width: 90%; max-width: 380px;
            background-color: var(--color-white-transparent); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(0,0,0,0.1); border-radius: 10px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: none; flex-direction: column; overflow: hidden;
            opacity: 0; transform: translateY(20px) scale(0.95);
            transition: opacity var(--transition-speed-medium) ease-out, transform var(--transition-speed-medium) ease-out, bottom var(--transition-speed-medium) ease-out;
            pointer-events: none;
        }
        .popup-container.open { display: flex; opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }

        #cart-popup { bottom: 215px; max-height: 45vh; z-index: 998; }
        #my-food-popup { bottom: 150px; max-height: 50vh; z-index: 999; }

        .popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 10px 15px;
            border-bottom: 1px solid var(--color-border); border-radius: 10px 10px 0 0; flex-shrink: 0;
        }
        .popup-header h3 { margin: 0; font-size: 1.1em; color: var(--color-darkest); }
        .popup-close-btn { background: none; border: none; font-size: 20px; cursor: pointer; color: var(--color-text-secondary); line-height: 1; }

        #cart-popup .popup-header { background-color: rgba(182, 173, 144, 0.8); } /* Specific header color */
        #my-food-popup .popup-header { background-color: rgba(164, 172, 134, 0.8); } /* Specific header color */

        .popup-items-list { padding: 5px 15px; overflow-y: auto; flex-grow: 1; }
        .popup-empty-message { text-align: center; color: var(--color-text-secondary); padding: 20px; }

        /* Cart Item Specific Styles */
        .cart-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee; font-size: 0.9em; }
        .cart-item:last-child { border-bottom: none; }
        .cart-item-details { flex-grow: 1; margin-right: 10px; }
        .cart-item-name { font-weight: bold; color: var(--color-dark-green); }
        .cart-item-price { color: var(--color-medium-beige); font-size: 0.9em; }
        .cart-item-controls { display: flex; align-items: center; flex-shrink: 0; }
        .cart-quantity-btn {
            background-color: #e9ecef; color: var(--color-text-secondary); border: 1px solid var(--color-border);
            border-radius: 4px; width: 25px; height: 25px; font-size: 16px; cursor: pointer;
            margin: 0 5px; line-height: 23px; text-align: center; transition: background-color var(--transition-speed-fast) ease;
        }
        .cart-quantity-btn:hover { background-color: #ced4da; }
        .cart-item-quantity { min-width: 20px; text-align: center; font-weight: bold; }
         .cart-remove-btn { background: none; border: none; color: var(--color-danger); font-size: 16px; cursor: pointer; margin-left: 10px; transition: color var(--transition-speed-fast) ease; padding: 0; }
         .cart-remove-btn:hover { color: #a0232f; }

         /* Ordered Item Specific Styles */
        .ordered-item {
            padding: 8px 0; border-bottom: 1px solid #eee; font-size: 0.9em;
            display: flex; justify-content: space-between; align-items: center;
        }
        .ordered-item:last-child { border-bottom: none; }
        .ordered-item-details { flex-grow: 1; margin-right: 10px; }
        .ordered-item-name { font-weight: bold; color: var(--color-dark-green); }
        .ordered-item-info { color: var(--color-medium-beige); font-size: 0.9em; }
        .ordered-item-total { font-weight: bold; color: var(--color-medium-beige); flex-shrink: 0;}
        #ordered-grand-total { text-align: right; font-weight: bold; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--color-border);}


        /* Popup Footer */
        .popup-footer {
            padding: 15px; border-top: 1px solid var(--color-border); background-color: var(--color-footer-transparent);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 0 0 10px 10px; flex-shrink: 0;
        }
        .cart-total { display: flex; justify-content: space-between; font-weight: bold; margin-bottom: 15px; font-size: 1.1em; }
        .popup-actions { display: flex; justify-content: center; gap: 10px; }
        .popup-action-btn {
            padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
            font-size: 0.9em; transition: opacity 0.2s ease, background-color 0.2s ease; flex-grow: 1; margin: 0;
        }
        .popup-action-btn:hover:not(:disabled) { opacity: 0.85; }
        .popup-action-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .order-btn { background-color: var(--color-light-green); color: var(--color-darkest); }
        .checkout-btn { background-color: var(--color-medium-beige); color: var(--color-white); }

        /* --- Table Number Display (Interactive) --- */
        #table-number-display {
            position: fixed; bottom: 10px; left: 10px; z-index: 1002;
            background-color: var(--color-medium-green); color: var(--color-white);
            font-family: 'Sarabun', 'Inter', sans-serif; font-size: 0.9rem; font-weight: bold;
            padding: 8px 15px; border-radius: 9999px; /* Capsule shape */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer; transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
            user-select: none;
        }
        #table-number-display:hover { background-color: var(--color-dark-green); transform: scale(1.05); }
        #table-number-display .table-icon { margin-right: 5px; }
        #table-number-display .placeholder-text { font-style: italic; opacity: 0.8; }


        /* --- Table Selection Modal --- */
        #table-select-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--color-modal-bg);
            display: none; justify-content: center; align-items: center; z-index: 1050;
            opacity: 0; transition: opacity var(--transition-speed-medium) ease;
        }
        #table-select-modal.open { display: flex; opacity: 1; }
        .table-select-content {
            background-color: var(--color-white); border-radius: 10px;
            padding: 20px; max-width: 90%; width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: scale(0.95); transition: transform var(--transition-speed-medium) ease;
        }
        #table-select-modal.open .table-select-content { transform: scale(1); }
        .table-select-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; border-bottom: 1px solid var(--color-border); padding-bottom: 10px;
        }
        .table-select-header h4 { margin: 0; font-size: 1.2em; color: var(--color-darkest); }
        .table-select-close-btn { background: none; border: none; font-size: 24px; cursor: pointer; color: var(--color-text-secondary); line-height: 1; padding: 0; }
        #table-list {
            max-height: 60vh; overflow-y: auto;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px; padding: 5px;
        }
        .table-list-item {
            padding: 10px; border: 1px solid var(--color-border); border-radius: 5px;
            text-align: center; font-weight: bold; cursor: pointer;
            background-color: var(--color-background);
            transition: background-color var(--transition-speed-fast) ease, color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease;
        }
        .table-list-item:hover {
            background-color: var(--color-lightest-green); color: var(--color-darkest); transform: scale(1.05);
        }
        .table-list-item.selected {
             background-color: var(--color-medium-green); color: var(--color-white); border-color: var(--color-dark-green);
         }

        /* --- First Load Prompt Notification --- */
        #table-prompt-notification {
            position: fixed; top: -100px; left: 50%; transform: translateX(-50%);
            background-color: var(--color-info); color: var(--color-white);
            padding: 10px 20px; border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); z-index: 1100;
            font-size: 0.9em; font-weight: bold; text-align: center;
            opacity: 0; transition: top var(--transition-speed-medium) ease-out, opacity var(--transition-speed-medium) ease-out;
        }
        #table-prompt-notification.show { top: 0; opacity: 1; }


        /* --- Responsive Adjustments --- */
        @media (min-width: 640px) {
             .bottom-menu { column-count: 3; }
             .container { padding: 0 20px; }
             #menu-name { font-size: 32px; }
             #menu-price { font-size: 20px; }
             .price-label { font-size: 0.8em; }
             .add-to-cart-button { width: 28px; height: 28px; line-height: 28px; font-size: 18px; }
             .top-section { width: calc(100% + 40px); margin-left: -20px; margin-right: -20px; }
             #menu-details { margin-left: 20px; margin-right: 20px; width: calc(100% - 40px); }
             #table-number-display { font-size: 1rem; bottom: 15px; left: 15px; padding: 10px 20px; }
             #table-prompt-notification { font-size: 1em; }
        }
        @media (min-width: 768px) { .bottom-menu { column-count: 4; } }
        @media (min-width: 1024px) { .bottom-menu { column-count: 5; } }
        @media (min-width: 1280px) { .bottom-menu { column-count: 6; } }

    </style>
</head>
<body>
    <div id="table-number-display" title="เลือกหมายเลขโต๊ะ" role="button" aria-haspopup="true" aria-controls="table-select-modal">
        <span id="table-number-text"><span class="placeholder-text">เลือกโต๊ะ</span></span>
    </div>

    <div id="table-select-modal" role="dialog" aria-modal="true" aria-labelledby="table-select-title">
        <div class="table-select-content">
            <div class="table-select-header">
                <h4 id="table-select-title">เลือกหมายเลขโต๊ะ</h4>
                <button class="table-select-close-btn" title="ปิด" aria-label="ปิดหน้าต่างเลือกโต๊ะ">&times;</button>
            </div>
            <div id="table-list">
                <p>กำลังโหลดรายการโต๊ะ...</p>
            </div>
        </div>
    </div>

    <div id="table-prompt-notification" role="alert">
        <i class="fas fa-info-circle"></i> กรุณาเลือกหมายเลขโต๊ะของท่านค่ะ
    </div>

    <main class="container">
        <section class="top-section" aria-labelledby="menu-name">
             <div class="image-container" id="image-swipe-area">
                 <img id="main-food-image" class="main-food-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="กำลังโหลดรูปภาพเมนู...">
             </div>
             <div id="menu-details">
                 <div class="menu-name-container">
                     <h2 id="menu-name">ชื่อเมนู</h2>
                 </div>
                 <p id="menu-description">คำอธิบายเมนูอาหาร</p>
                 <p id="menu-price">
                     <span class="price-item hidden">
                         <span class="price-label" id="label-small">เล็ก:</span>
                         <span class="price-value" id="price-small">฿0</span>
                         <button class="add-to-cart-button" data-size="Small" title="เพิ่มขนาดเล็กลงตระกร้า" aria-label="เพิ่มขนาดเล็กลงตระกร้า">+</button>
                     </span>
                      <span class="price-separator hidden" id="price-sep-small">|</span>
                     <span class="price-item hidden">
                         <span class="price-label" id="label-normal">ปกติ:</span>
                         <span class="price-value" id="price-normal">฿0</span>
                         <button class="add-to-cart-button" data-size="Normal" title="เพิ่มขนาดปกติลงตระกร้า" aria-label="เพิ่มขนาดปกติลงตระกร้า">+</button>
                     </span>
                     <span class="price-separator hidden" id="price-sep">|</span>
                     <span class="price-item hidden">
                         <span class="price-label" id="label-extra">พิเศษ:</span>
                         <span class="price-value" id="price-extra">฿0</span>
                         <button class="add-to-cart-button" data-size="Extra" title="เพิ่มขนาดพิเศษลงตระกร้า" aria-label="เพิ่มขนาดพิเศษลงตระกร้า">+</button>
                     </span>
                     <span class="price-separator hidden" id="price-sep-family">|</span>
                     <span class="price-item hidden">
                         <span class="price-label" id="label-family">ครอบครัว:</span>
                         <span class="price-value" id="price-family">฿0</span>
                         <button class="add-to-cart-button" data-size="Family" title="เพิ่มขนาดครอบครัวลงตระกร้า" aria-label="เพิ่มขนาดครอบครัวลงตระกร้า">+</button>
                     </span>
                 </p>
             </div>
        </section>

        <nav class="category-bar" aria-label="หมวดหมู่เมนูอาหาร">
             <p>กำลังโหลดหมวดหมู่...</p>
         </nav>

        <section class="bottom-menu" aria-live="polite">
            <p style="text-align: center; color: var(--color-text-secondary); grid-column: 1 / -1;">กำลังโหลดรายการอาหาร...</p>
        </section>

    </main> <button id="call-staff-icon-container" class="floating-icon" title="เรียกพนักงาน" aria-label="เรียกพนักงาน">
        <i class="fas fa-bell"></i>
    </button>

    <button id="my-food-icon-container" class="floating-icon" title="เปิด/ปิด รายการอาหารของฉัน" aria-label="เปิด/ปิด รายการอาหารของฉัน" aria-haspopup="true" aria-controls="my-food-popup" aria-expanded="false">
        <i class="fas fa-receipt"></i>
        <span id="my-food-item-count" class="badge hidden" aria-label="จำนวนรายการอาหารที่สั่งแล้ว">0</span>
    </button>

    <button id="cart-icon-container" class="floating-icon" title="เปิด/ปิด ตระกร้า" aria-label="เปิด/ปิด ตระกร้าสินค้า" aria-haspopup="true" aria-controls="cart-popup" aria-expanded="false">
        <i class="fas fa-shopping-cart"></i>
        <span id="cart-item-count" class="badge hidden" aria-label="จำนวนรายการในตระกร้า">0</span>
    </button>

    <div id="my-food-popup" class="popup-container" role="dialog" aria-modal="true" aria-labelledby="my-food-title">
        <div class="popup-header my-food-header">
            <h3 id="my-food-title">รายการอาหารที่สั่งแล้ว</h3>
            <button class="popup-close-btn my-food-close-btn" title="ปิดรายการ" aria-label="ปิดหน้าต่างรายการอาหารที่สั่งแล้ว">&times;</button>
        </div>
        <div id="my-food-items-list" class="popup-items-list">
            <p class="popup-empty-message my-food-empty-message">ยังไม่มีรายการอาหารที่สั่ง</p>
            </div>
        <div id="ordered-grand-total" class="hidden">ยอดรวมที่สั่งแล้ว: ฿0</div>
        <div class="popup-footer my-food-footer">
            <div class="popup-actions my-food-actions">
                <button class="popup-action-btn checkout-btn" id="my-food-checkout-button" disabled>ชำระเงิน</button>
            </div>
        </div>
    </div>

    <div id="cart-popup" class="popup-container" role="dialog" aria-modal="true" aria-labelledby="cart-title">
        <div class="popup-header cart-header">
            <h3 id="cart-title">ตระกร้าสินค้า</h3>
            <button class="popup-close-btn cart-close-btn" title="ปิดตระกร้า" aria-label="ปิดหน้าต่างตระกร้าสินค้า">&times;</button>
        </div>
        <div id="cart-items-list" class="popup-items-list">
            <p class="popup-empty-message cart-empty-message">ตระกร้าของคุณว่างเปล่า</p>
            </div>
        <div class="popup-footer cart-footer">
            <div class="cart-total">
                <span>รวมทั้งหมด:</span>
                <span id="cart-total-price">฿0</span>
            </div>
            <div class="popup-actions cart-actions">
                <button class="popup-action-btn order-btn" id="order-button" disabled>สั่งรายการอาหาร</button>
            </div>
        </div>
    </div>

<script>
    // ========================================================================
    // CONFIGURATION
    // ========================================================================
    const CONFIG = {
        // *** สำคัญ: ใส่ URL ที่ได้จากการ Deploy Google Apps Script ของคุณที่นี่ ***
        GOOGLE_SCRIPT_URL: "https://script.google.com/macros/s/AKfycbw0WKQF9hSuKa26YSHE4zpbJRXTIHVu4ITaKzS3LYlB3m1Y_oAPpyLvt7y1PYN2hAQ/exec", // <--- ใส่ URL ที่ถูกต้องที่นี่
        TABLE_NUMBER_PREFIX: "โต๊ะ ",
        MAX_TABLE_NUMBER: 30,
        TABLE_SELECT_PROMPT_MESSAGE: "กรุณาเลือกหมายเลขโต๊ะของท่านค่ะ",
        PLACEHOLDER_IMAGE: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', // Simple transparent pixel
        STORAGE_KEYS: {
            TABLE: 'selectedTableData_v116', // Updated version maybe?
            CART: 'menuCartData_v116_db',    // Updated version maybe?
            ORDERED: 'menuOrderedItemsData_v116_db' // Updated version maybe?
        },
        EXPIRY_HOURS: {
            TABLE: 6
        },
        ANIMATION_SPEED_MS: 300, // Corresponds to --transition-speed-medium
        SWIPE_THRESHOLD_PX: 50,
        CATEGORY_ICONS: { // ไอคอนสำหรับหมวดหมู่ (ปรับแก้ตามชื่อหมวดหมู่ใน Sheet)
             "จานหลัก": "fas fa-utensils",
             "เฮลท์ตี้ โบวล์": "fas fa-seedling",
             "ทานเล่น": "fas fa-cookie-bite",
             "สลัด": "fas fa-leaf",
             "ทะเล": "fas fa-fish",
             "ของหวาน": "fas fa-ice-cream",
             "เครื่องดื่ม": "fas fa-coffee",
             "ซุป": "fas fa-mug-hot",
             "default": "fas fa-question-circle" // ไอคอนเริ่มต้น ถ้าไม่พบ mapping
         }
    };

    // ========================================================================
    // GLOBAL STATE VARIABLES
    // ========================================================================
    let menuData = [];
    let allCategories = [];
    let cartItems = [];
    let orderedItems = [];
    let selectedTableNumber = null;
    let currentDisplayedItemId = null;
    let currentCategory = null;
    let currentFilteredItems = [];
    let currentDisplayIndex = -1;
    let isApiLoading = { // Track loading states for different actions
        menu: false,
        order: false,
        callStaff: false,
        checkout: false
    };

    // ========================================================================
    // DOM ELEMENT CACHING
    // ========================================================================
    // Cache elements used frequently to avoid repeated lookups
    const DOMElements = {
        tableNumberDisplay: document.getElementById('table-number-display'),
        tableNumberText: document.getElementById('table-number-text'),
        tableSelectModal: document.getElementById('table-select-modal'),
        tableListContainer: document.getElementById('table-list'),
        tableSelectCloseBtn: document.querySelector('#table-select-modal .table-select-close-btn'),
        tablePromptNotification: document.getElementById('table-prompt-notification'),
        mainFoodImage: document.getElementById('main-food-image'),
        imageContainer: document.getElementById('image-swipe-area'),
        bottomMenuContainer: document.querySelector('.bottom-menu'),
        categoryBarContainer: document.querySelector('.category-bar'),
        menuDetailsContainer: document.getElementById('menu-details'),
        menuNameElement: document.getElementById('menu-name'),
        menuDescriptionElement: document.getElementById('menu-description'),
        menuPriceContainer: document.getElementById('menu-price'),
        cartIcon: document.getElementById('cart-icon-container'),
        cartItemCountBadge: document.getElementById('cart-item-count'),
        cartPopup: document.getElementById('cart-popup'),
        cartItemsList: document.getElementById('cart-items-list'),
        cartTotalPriceElement: document.getElementById('cart-total-price'),
        cartCloseBtn: document.querySelector('#cart-popup .cart-close-btn'),
        orderButton: document.getElementById('order-button'),
        myFoodIcon: document.getElementById('my-food-icon-container'),
        myFoodItemCountBadge: document.getElementById('my-food-item-count'),
        myFoodPopup: document.getElementById('my-food-popup'),
        myFoodItemsList: document.getElementById('my-food-items-list'),
        myFoodCloseBtn: document.querySelector('#my-food-popup .my-food-close-btn'),
        myFoodCheckoutButton: document.getElementById('my-food-checkout-button'),
        callStaffIcon: document.getElementById('call-staff-icon-container'),
        orderedGrandTotal: document.getElementById('ordered-grand-total'),
        // Cache for price elements (populated later in setup)
        priceElementsCache: {}
    };

    function setupPriceElementCache() {
         const sizes = ['Small', 'Normal', 'Extra', 'Family'];
         sizes.forEach(size => {
             const lowerSize = size.toLowerCase();
             const button = DOMElements.menuPriceContainer?.querySelector(`button[data-size="${size}"]`);
             DOMElements.priceElementsCache[size] = {
                 label: document.getElementById(`label-${lowerSize}`),
                 value: document.getElementById(`price-${lowerSize}`),
                 button: button,
                 separator: document.getElementById(`price-sep-${lowerSize}`) || (size === 'Extra' ? document.getElementById('price-sep') : null), // Handle specific IDs
                 parentSpan: button?.closest('.price-item')
             };
         });
    }


    // ========================================================================
    // UTILITY FUNCTIONS
    // ========================================================================
    function getCurrentDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function getExpiryTimestamp(hours) {
        return Date.now() + hours * 60 * 60 * 1000;
    }

    function formatPrice(price) {
        // Handle potential null/undefined price before formatting
        if (price === null || price === undefined || isNaN(price)) {
            return 'N/A'; // Or '฿-' or similar representation for missing price
        }
        return `฿${Number(price).toLocaleString()}`;
    }

    // Function to set loading state for buttons/icons
    function setLoadingState(elementType, action, isLoading) {
        isApiLoading[action] = isLoading;
        let element;
        let originalContent;

        switch (elementType) {
            case 'button':
                if (action === 'order') element = DOMElements.orderButton;
                else if (action === 'checkout') element = DOMElements.myFoodCheckoutButton;
                break;
            case 'icon':
                 if (action === 'callStaff') element = DOMElements.callStaffIcon;
                break;
        }

        if (!element) return;

        if (isLoading) {
            element.disabled = true;
            // Store original content if not already stored
            if (!element.dataset.originalContent) {
                element.dataset.originalContent = element.innerHTML;
            }
            element.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
            // Add loading text for non-icon buttons
            if (elementType === 'button') {
                 if (action === 'order') element.innerHTML += ' กำลังสั่ง...';
                 else if (action === 'checkout') element.innerHTML += ' กำลังเรียก...';
            }
        } else {
            // Re-enable based on conditions, not just unconditionally
            // element.disabled = false; // Moved to specific update functions like updateOrderButtonState

             // Restore original content only if it was stored
            if (element.dataset.originalContent) {
                element.innerHTML = element.dataset.originalContent;
                delete element.dataset.originalContent; // Clean up
            }
            // Re-evaluate disabled state after loading finishes
             if (action === 'order') updateOrderButtonState();
             if (action === 'checkout') updateCheckoutButtonState();
             if (action === 'callStaff') updateCallStaffButtonState(); // Added for completeness
        }
    }

     // Function to update call staff button state (mainly for disabling while loading)
     function updateCallStaffButtonState() {
         if (DOMElements.callStaffIcon) {
             DOMElements.callStaffIcon.disabled = isApiLoading.callStaff;
             // Optional: Add a title if needed when disabled, e.g., "กำลังเรียกพนักงาน..."
         }
     }

    // ========================================================================
    // API SERVICE FUNCTIONS (Interaction with Google Apps Script)
    // ========================================================================
    async function callBackendApi(action, payload = {}, method = 'POST') {
        if (!CONFIG.GOOGLE_SCRIPT_URL || CONFIG.GOOGLE_SCRIPT_URL === "YOUR_GOOGLE_SCRIPT_URL_HERE") {
            console.error("Google Script URL is not set in CONFIG.");
            alert("🚨 ข้อผิดพลาด: การตั้งค่าสคริปต์ไม่ถูกต้อง โปรดติดต่อผู้ดูแล (URL Missing)");
            return { success: false, message: "Script URL not configured" };
        }

        const url = `${CONFIG.GOOGLE_SCRIPT_URL}?action=${action}`;
        const options = {
            method: method,
            headers: {}, // Initialize headers
            // redirect: 'follow', // Usually default, but can be explicit if needed
        };

        // Only add Content-Type and body for POST requests with payload
        if (method === 'POST' && payload && Object.keys(payload).length > 0) {
            options.headers['Content-Type'] = 'application/json';
            options.body = JSON.stringify(payload);
        }

        try {
            console.log(`Calling backend: ${method} ${url}`, method === 'POST' ? payload : '');
            const response = await fetch(url, options);

            // Check for non-JSON responses or failed fetch
            if (!response.ok) {
                 let errorText = `HTTP error ${response.status}: ${response.statusText}`;
                 let serverResponseMessage = '';
                 try {
                     // Attempt to read the response body for more details
                     serverResponseMessage = await response.text();
                     errorText += `\nServer Response: ${serverResponseMessage.substring(0, 200)}...`;
                 } catch (e) {
                    console.warn("Could not read error response body:", e);
                 }
                // Log the detailed error for debugging
                 console.error(`Backend API Error (${action}): ${errorText}`);
                 // Provide a user-friendly message
                 alert(`🚨 เกิดข้อผิดพลาด (${response.status}) ในการติดต่อเซิร์ฟเวอร์ (${action}). โปรดลองใหม่อีกครั้ง หรือแจ้งพนักงาน.\n${serverResponseMessage.substring(0,100)}`);
                 return { success: false, message: `HTTP error ${response.status}` }; // Return structured error
            }

             // Attempt to parse JSON, handle potential errors
             let result;
             try {
                 const contentType = response.headers.get("content-type");
                 if (!contentType || !contentType.includes("application/json")) {
                     const textResponse = await response.text();
                     console.warn(`Non-JSON response received from action '${action}'. Status: ${response.status}. Body:`, textResponse);
                     // Handle based on status or content if needed, otherwise treat as unexpected
                     throw new Error(`Expected JSON, but got ${contentType || 'unknown'}. Response: ${textResponse.substring(0, 100)}...`);
                 }
                 result = await response.json();
             } catch (parseError) {
                 console.error(`Error parsing JSON response for action '${action}':`, parseError);
                 alert(`🚨 เกิดข้อผิดพลาดในการประมวลผลข้อมูลตอบกลับจากเซิร์ฟเวอร์ (${action}).`);
                 return { success: false, message: `JSON Parse Error: ${parseError.message}` };
             }


            console.log(`Backend response for action '${action}':`, result);
            // Basic validation of expected success flag
            if (typeof result.success !== 'boolean') {
                console.warn(`Backend response for '${action}' missing or invalid 'success' flag.`, result);
                // Treat as failure unless specific logic dictates otherwise
                // return { success: false, message: "Invalid response format from server", data: result };
            }

            return result; // Assuming GAS returns { success: boolean, message?: string, ...data }

        } catch (networkError) {
            // Handle fetch-related errors (network down, DNS issues, CORS if misconfigured server-side)
            console.error(`Network or fetch error calling backend API for action '${action}':`, networkError);
             alert(`🚨 เกิดข้อผิดพลาดในการเชื่อมต่อ (${action}). โปรดตรวจสอบการเชื่อมต่ออินเทอร์เน็ต หรือติดต่อพนักงาน.`);
            return { success: false, message: `Network Error: ${networkError.message}` };
        }
    }

    async function fetchMenuData() {
        console.log("Fetching menu data from Google Sheet...");
        setLoadingState(null, 'menu', true); // Use a generic loading state for menu data
        // Display loading indicators
        if (DOMElements.categoryBarContainer) DOMElements.categoryBarContainer.innerHTML = '<p>กำลังโหลดหมวดหมู่...</p>';
        if (DOMElements.bottomMenuContainer) DOMElements.bottomMenuContainer.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary); grid-column: 1 / -1;">กำลังโหลดรายการอาหาร...</p>';


        // Use 'getMenu' action name matching the Apps Script doGet/doPost logic
        const result = await callBackendApi('getMenu', null, 'GET');

        setLoadingState(null, 'menu', false);

        // Check specifically for success and expected data arrays
        if (result && result.success && Array.isArray(result.menuData) && Array.isArray(result.categories)) {
            console.log("Menu data fetched successfully:", result.menuData.length, "items,", result.categories.length, "categories.");
            menuData = result.menuData;
            allCategories = result.categories;
            return true;
        } else {
            // Log the actual result for debugging if it exists but wasn't successful/valid
            console.error('Error fetching or processing menu data:', result?.message || 'Invalid data structure or failed request.', result);
            // Display error message using the message from the backend if available
            const errorMsg = `❌ เกิดข้อผิดพลาดในการโหลดข้อมูลเมนู: ${result?.message || 'ไม่สามารถเชื่อมต่อหรือข้อมูลไม่ถูกต้อง'}. โปรดลองรีเฟรชหน้า หรือติดต่อพนักงาน`;
            if (DOMElements.categoryBarContainer) DOMElements.categoryBarContainer.innerHTML = `<p style="color: red; padding: 10px;">${errorMsg}</p>`;
            if (DOMElements.bottomMenuContainer) DOMElements.bottomMenuContainer.innerHTML = ''; // Clear loading message
            menuData = [];
            allCategories = [];
            return false;
        }
    }

    // ========================================================================
    // TABLE SELECTION LOGIC
    // ========================================================================
    function openTableSelectModal() {
        if (DOMElements.tableSelectModal) {
            const listItems = DOMElements.tableListContainer?.querySelectorAll('.table-list-item');
            listItems?.forEach(item => {
                item.classList.toggle('selected', item.dataset.table === selectedTableNumber);
            });
            DOMElements.tableSelectModal.classList.add('open');
             // Focus the container or the close button for accessibility
             DOMElements.tableSelectCloseBtn?.focus();
        }
    }

    function closeTableSelectModal() {
        if (DOMElements.tableSelectModal) {
            DOMElements.tableSelectModal.classList.remove('open');
            DOMElements.tableNumberDisplay?.focus(); // Return focus
        }
    }

    function populateTableList(maxTables) {
        if (!DOMElements.tableListContainer) return;
        DOMElements.tableListContainer.innerHTML = ''; // Clear loading message
        const fragment = document.createDocumentFragment();
        for (let i = 1; i <= maxTables; i++) {
            const tableNum = String(i);
            const listItem = document.createElement('div');
            listItem.classList.add('table-list-item');
            listItem.textContent = tableNum;
            listItem.dataset.table = tableNum;
            listItem.setAttribute('role', 'button');
            listItem.setAttribute('tabindex', '0'); // Make it focusable
            listItem.addEventListener('click', () => selectTable(tableNum));
            listItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') selectTable(tableNum); });
            fragment.appendChild(listItem);
        }
        DOMElements.tableListContainer.appendChild(fragment);
    }

    function selectTable(tableNum) {
        selectedTableNumber = tableNum;
        updateTableDisplay(tableNum);
        saveSelectedTable(tableNum);
        closeTableSelectModal();
        document.title = `เมนูอาหาร - ${CONFIG.TABLE_NUMBER_PREFIX}${tableNum}`;
        hideTablePromptNotification();
         updateOrderButtonState(); // Update buttons that depend on table selection
         updateCheckoutButtonState();
    }

    function updateTableDisplay(tableNum) {
        if (DOMElements.tableNumberText) {
            if (tableNum) {
                DOMElements.tableNumberText.innerHTML = `<i class="fas fa-chair table-icon"></i>${CONFIG.TABLE_NUMBER_PREFIX}${tableNum}`;
                DOMElements.tableNumberText.classList.remove('placeholder-text');
            } else {
                DOMElements.tableNumberText.innerHTML = `<span class="placeholder-text">เลือกโต๊ะ</span>`;
                DOMElements.tableNumberText.classList.add('placeholder-text');
                document.title = 'เมนูอาหาร - เลือกโต๊ะ';
            }
        }
    }

    function saveSelectedTable(tableNum) {
        const expiry = getExpiryTimestamp(CONFIG.EXPIRY_HOURS.TABLE);
        const data = { tableNumber: tableNum, expiry: expiry };
        try {
            localStorage.setItem(CONFIG.STORAGE_KEYS.TABLE, JSON.stringify(data));
        } catch (error) { console.error("LS Error (Save Table):", error); }
    }

    function loadSelectedTable() {
        try {
            const storedData = localStorage.getItem(CONFIG.STORAGE_KEYS.TABLE);
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                if (parsedData?.tableNumber && parsedData.expiry && Date.now() < parsedData.expiry) {
                    return parsedData.tableNumber;
                } else { localStorage.removeItem(CONFIG.STORAGE_KEYS.TABLE); }
            }
        } catch (error) { console.error("LS Error (Load Table):", error); localStorage.removeItem(CONFIG.STORAGE_KEYS.TABLE); }
        return null;
    }

    function showTablePromptNotification() { if (DOMElements.tablePromptNotification) DOMElements.tablePromptNotification.classList.add('show'); }
    function hideTablePromptNotification() { if (DOMElements.tablePromptNotification) DOMElements.tablePromptNotification.classList.remove('show'); }

    // ========================================================================
    // LOCAL STORAGE (Cart & Ordered Items)
    // ========================================================================
    function saveCartToLocalStorage() {
        const cartData = { date: getCurrentDateString(), items: cartItems };
        try { localStorage.setItem(CONFIG.STORAGE_KEYS.CART, JSON.stringify(cartData)); }
        catch (error) { console.error("LS Error (Save Cart):", error); }
    }

    function loadCartFromLocalStorage() {
        cartItems = [];
        try {
            const storedData = localStorage.getItem(CONFIG.STORAGE_KEYS.CART);
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                // Basic validation: check if it's an object with an items array
                if (parsedData && typeof parsedData === 'object' && Array.isArray(parsedData.items)) {
                     // Further validation on items if needed (e.g., check required properties)
                     cartItems = parsedData.items.filter(item => item && item.cartId && item.id && item.name && item.size && typeof item.quantity === 'number' && typeof item.price === 'number');
                     if (cartItems.length !== parsedData.items.length) {
                         console.warn("Some invalid items removed from loaded cart data.");
                     }
                 } else {
                     console.warn("Invalid cart data structure found in local storage. Clearing.");
                     localStorage.removeItem(CONFIG.STORAGE_KEYS.CART);
                 }
            }
        } catch (error) {
            console.error("LS Error (Load Cart):", error);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.CART);
        }
    }

    function saveOrderedItemsToLocalStorage() {
        const orderedData = { date: getCurrentDateString(), items: orderedItems };
        try { localStorage.setItem(CONFIG.STORAGE_KEYS.ORDERED, JSON.stringify(orderedData)); }
        catch (error) { console.error("LS Error (Save Ordered):", error); }
    }

    function loadOrderedItemsFromLocalStorage() {
        orderedItems = [];
        try {
            const storedData = localStorage.getItem(CONFIG.STORAGE_KEYS.ORDERED);
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                 if (parsedData && typeof parsedData === 'object' && Array.isArray(parsedData.items)) {
                    // Validation similar to cart loading
                     orderedItems = parsedData.items.filter(item => item && item.cartId && item.id && item.name && item.size && typeof item.quantity === 'number' && typeof item.price === 'number');
                     if (orderedItems.length !== parsedData.items.length) {
                         console.warn("Some invalid items removed from loaded ordered items data.");
                     }
                 } else {
                     console.warn("Invalid ordered items data structure found in local storage. Clearing.");
                     localStorage.removeItem(CONFIG.STORAGE_KEYS.ORDERED);
                 }
            }
        } catch (error) {
            console.error("LS Error (Load Ordered):", error);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.ORDERED);
        }
    }

    // ========================================================================
    // CART LOGIC
    // ========================================================================
    function addToCart(itemId, size) {
        const product = menuData.find(item => item.id === itemId);
        // Ensure product and prices exist
        if (!product?.prices || typeof product.prices !== 'object') {
            console.error("Product or prices object not found for ID:", itemId);
            alert("ขออภัย ไม่พบข้อมูลราคาสินค้านี้");
            return;
        }
        const price = product.prices[size];
        // Ensure price for the specific size is valid
        if (price === null || price === undefined || isNaN(price)) {
            console.error(`Invalid or missing price for item ${itemId}, size ${size}:`, price);
            alert(`ขออภัย ไม่พบราคาสำหรับขนาด ${size} ของสินค้านี้`);
            return;
        }

        const cartItemId = `${itemId}-${size}`; // Unique ID for item+size combination
        const existingItemIndex = cartItems.findIndex(item => item.cartId === cartItemId);

        if (existingItemIndex > -1) {
            cartItems[existingItemIndex].quantity++;
        } else {
            // Ensure all necessary properties are added
            cartItems.push({
                 cartId: cartItemId,
                 id: product.id,
                 name: product.name,
                 price: price,
                 size: size,
                 quantity: 1
             });
        }

        saveCartToLocalStorage();
        renderCart();
        updateCartIcon();
        // Visual feedback on icon
        DOMElements.cartIcon?.classList.add('updated');
        setTimeout(() => { DOMElements.cartIcon?.classList.remove('updated'); }, CONFIG.ANIMATION_SPEED_MS + 50);
    }

    function updateQuantity(cartId, change) {
        const itemIndex = cartItems.findIndex(item => item.cartId === cartId);
        if (itemIndex > -1) {
            const newQuantity = cartItems[itemIndex].quantity + change;
            if (newQuantity <= 0) {
                // Remove item if quantity is zero or less
                cartItems.splice(itemIndex, 1);
            } else {
                cartItems[itemIndex].quantity = newQuantity;
            }
            saveCartToLocalStorage();
            renderCart(); // Re-render the entire cart
            updateCartIcon();
        } else {
            console.warn("Attempted to update quantity for non-existent cart item ID:", cartId);
        }
    }

    function removeFromCart(cartId) {
         const itemIndex = cartItems.findIndex(item => item.cartId === cartId);
         if (itemIndex > -1) {
             cartItems.splice(itemIndex, 1);
             saveCartToLocalStorage();
             renderCart();
             updateCartIcon();
         } else {
             console.warn("Attempted to remove non-existent cart item ID:", cartId);
         }
    }

    // ========================================================================
    // RENDERING FUNCTIONS
    // ========================================================================

     // --- Rendering: Cart ---
    function renderCart() {
        if (!DOMElements.cartItemsList || !DOMElements.cartTotalPriceElement) return;

        DOMElements.cartItemsList.innerHTML = ''; // Clear previous items
        let totalPrice = 0;

        if (cartItems.length === 0) {
            DOMElements.cartItemsList.innerHTML = '<p class="popup-empty-message cart-empty-message">ตระกร้าของคุณว่างเปล่า</p>';
        } else {
            const fragment = document.createDocumentFragment();
            cartItems.forEach(item => {
                // Basic check for item validity before rendering
                if (!item || typeof item.price !== 'number' || typeof item.quantity !== 'number') {
                     console.warn("Skipping invalid cart item:", item);
                     return; // Skip this item
                 }

                const itemElement = document.createElement('div');
                itemElement.classList.add('cart-item');
                const itemPrice = item.price;
                const itemQuantity = item.quantity;
                const itemTotalPrice = itemPrice * itemQuantity;
                totalPrice += itemTotalPrice;

                // Sanitize names before inserting into HTML
                const safeItemName = item.name?.replace(/</g, "&lt;")?.replace(/>/g, "&gt;") || 'N/A';
                const safeItemSize = item.size?.replace(/</g, "&lt;")?.replace(/>/g, "&gt;") || 'N/A';

                itemElement.innerHTML = `
                    <div class="cart-item-details">
                        <div class="cart-item-name">${safeItemName} (${safeItemSize})</div>
                        <div class="cart-item-price">${formatPrice(itemPrice)} x ${itemQuantity} = ${formatPrice(itemTotalPrice)}</div>
                    </div>
                    <div class="cart-item-controls">
                        <button class="cart-quantity-btn decrease-qty" data-cartid="${item.cartId}" aria-label="ลดจำนวน ${safeItemName} (${safeItemSize})">-</button>
                        <span class="cart-item-quantity" aria-live="polite">${itemQuantity}</span>
                        <button class="cart-quantity-btn increase-qty" data-cartid="${item.cartId}" aria-label="เพิ่มจำนวน ${safeItemName} (${safeItemSize})">+</button>
                        <button class="cart-remove-btn" data-cartid="${item.cartId}" title="ลบรายการนี้" aria-label="ลบ ${safeItemName} (${safeItemSize}) ออกจากตระกร้า"><i class="fas fa-trash-alt" aria-hidden="true"></i></button>
                    </div>`;

                // Add event listeners directly (more reliable than delegation for items created dynamically here)
                itemElement.querySelector('.decrease-qty')?.addEventListener('click', () => updateQuantity(item.cartId, -1));
                itemElement.querySelector('.increase-qty')?.addEventListener('click', () => updateQuantity(item.cartId, 1));
                itemElement.querySelector('.cart-remove-btn')?.addEventListener('click', () => removeFromCart(item.cartId));

                fragment.appendChild(itemElement);
            });
            DOMElements.cartItemsList.appendChild(fragment);
        }

        DOMElements.cartTotalPriceElement.textContent = formatPrice(totalPrice);
        updateOrderButtonState(); // Update button state based on cart content and other conditions
    }

    function updateOrderButtonState() {
         if (DOMElements.orderButton) {
             // Can order if cart is not empty, a table is selected, AND the order API is not currently loading
             const canOrder = cartItems.length > 0 && selectedTableNumber && !isApiLoading.order;
             DOMElements.orderButton.disabled = !canOrder;

             // Set appropriate title based on state
             let title = "";
             if (isApiLoading.order) {
                 title = "กำลังดำเนินการ...";
             } else if (cartItems.length === 0) {
                 title = "ตระกร้าว่างเปล่า";
             } else if (!selectedTableNumber) {
                 title = "กรุณาเลือกโต๊ะก่อน";
             } else {
                 title = "สั่งรายการอาหาร";
             }
             DOMElements.orderButton.title = title;
         }
     }

    function updateCartIcon() {
        if (!DOMElements.cartItemCountBadge || !DOMElements.cartIcon) return;
        const totalQuantity = cartItems.reduce((sum, item) => sum + (item?.quantity || 0), 0); // Add safety check for item
        DOMElements.cartItemCountBadge.textContent = totalQuantity;
        DOMElements.cartItemCountBadge.classList.toggle('hidden', totalQuantity === 0);
        DOMElements.cartIcon.setAttribute('aria-label', `เปิด/ปิด ตระกร้าสินค้า (${totalQuantity} รายการ)`);
    }


    // --- Rendering: Ordered Items ---
    function renderOrderedItems() {
         if (!DOMElements.myFoodItemsList || !DOMElements.myFoodCheckoutButton || !DOMElements.orderedGrandTotal) return;
         DOMElements.myFoodItemsList.innerHTML = ''; // Clear previous items
         let hasOrderedItems = orderedItems.length > 0;
         let grandOrderedTotal = 0;

         if (!hasOrderedItems) {
             DOMElements.myFoodItemsList.innerHTML = '<p class="popup-empty-message my-food-empty-message">ยังไม่มีรายการอาหารที่สั่ง</p>';
             DOMElements.orderedGrandTotal.classList.add('hidden');
         } else {
             const fragment = document.createDocumentFragment();
             orderedItems.forEach(item => {
                  // Basic check for item validity before rendering
                 if (!item || typeof item.price !== 'number' || typeof item.quantity !== 'number') {
                     console.warn("Skipping invalid ordered item:", item);
                     return; // Skip this item
                 }

                 const itemElement = document.createElement('div');
                 itemElement.classList.add('ordered-item');
                 const itemPrice = item.price;
                 const itemQuantity = item.quantity;
                 const itemTotalPrice = itemPrice * itemQuantity;
                 grandOrderedTotal += itemTotalPrice;

                 const safeItemName = item.name?.replace(/</g, "&lt;")?.replace(/>/g, "&gt;") || 'N/A';
                 const safeItemSize = item.size?.replace(/</g, "&lt;")?.replace(/>/g, "&gt;") || 'N/A';

                 itemElement.innerHTML = `
                     <div class="ordered-item-details">
                         <div class="ordered-item-name">${safeItemName} (${safeItemSize})</div>
                         <div class="ordered-item-info">จำนวน: ${itemQuantity} (${formatPrice(itemPrice)}/ชิ้น)</div>
                     </div>
                     <div class="ordered-item-total">
                        ${formatPrice(itemTotalPrice)}
                     </div>`;
                 fragment.appendChild(itemElement);
             });
             DOMElements.myFoodItemsList.appendChild(fragment);

             // Display total ordered amount
             DOMElements.orderedGrandTotal.textContent = `ยอดรวมที่สั่งแล้ว: ${formatPrice(grandOrderedTotal)}`;
             DOMElements.orderedGrandTotal.classList.remove('hidden');
         }

         updateCheckoutButtonState();
    }

    function updateCheckoutButtonState() {
        if (DOMElements.myFoodCheckoutButton) {
             // Can checkout if there are ordered items, a table is selected, AND the checkout API is not loading
             const canCheckout = orderedItems.length > 0 && selectedTableNumber && !isApiLoading.checkout;
             DOMElements.myFoodCheckoutButton.disabled = !canCheckout;

             let title = "";
              if (isApiLoading.checkout) {
                  title = "กำลังดำเนินการ...";
              } else if (orderedItems.length === 0) {
                  title = "ไม่มีรายการที่สั่ง";
              } else if (!selectedTableNumber) {
                  title = "กรุณาเลือกโต๊ะก่อน";
              } else {
                  title = "เรียกชำระเงิน";
              }
             DOMElements.myFoodCheckoutButton.title = title;
         }
     }

    function updateMyFoodIcon() {
         if (!DOMElements.myFoodItemCountBadge || !DOMElements.myFoodIcon) return;
         const totalQuantity = orderedItems.reduce((sum, item) => sum + (item?.quantity || 0), 0); // Add safety check
         DOMElements.myFoodItemCountBadge.textContent = totalQuantity;
         DOMElements.myFoodItemCountBadge.classList.toggle('hidden', totalQuantity === 0);
         DOMElements.myFoodIcon.setAttribute('aria-label', `เปิด/ปิด รายการอาหารของฉัน (${totalQuantity} รายการ)`);
     }

    // --- Rendering: Main Menu Item Details (Decomposed) ---
    function updateImageWithAnimation(newSrc, alt, direction = 'none') {
        if (!DOMElements.mainFoodImage || !DOMElements.imageContainer) return;

        const currentImageSrc = DOMElements.mainFoodImage.getAttribute('src');
        const placeholderSrc = CONFIG.PLACEHOLDER_IMAGE;
        const safeAlt = alt?.replace(/"/g, '&quot;') || 'รูปภาพเมนู'; // Sanitize alt text

        const updateImageElement = (src) => {
            DOMElements.mainFoodImage.src = src || placeholderSrc;
            DOMElements.mainFoodImage.alt = src ? safeAlt : 'ไม่มีรูปภาพ';
            // Clear previous error handlers before setting a new one
             DOMElements.mainFoodImage.onerror = null;
             DOMElements.mainFoodImage.onerror = () => {
                console.warn(`Image failed to load: ${src}. Using placeholder.`);
                // Prevent infinite loop if placeholder itself fails
                 if (DOMElements.mainFoodImage.src !== placeholderSrc) {
                     DOMElements.mainFoodImage.src = placeholderSrc;
                 }
                 DOMElements.mainFoodImage.alt = `${safeAlt} (Image unavailable)`;
            };
        };

        // Reset ongoing animations immediately
        DOMElements.imageContainer.classList.remove('slide-out-left', 'slide-in-right', 'slide-out-right', 'slide-in-left');
        DOMElements.mainFoodImage.getAnimations().forEach(anim => anim.cancel()); // Force cancel JS animations if any

        // Determine if animation is needed
        const needsAnimation = direction !== 'none' && currentImageSrc && currentImageSrc !== newSrc && currentImageSrc !== placeholderSrc;

        if (needsAnimation) {
            let outClass = direction === 'next' ? 'slide-out-left' : 'slide-out-right';
            let inClass = direction === 'next' ? 'slide-in-right' : 'slide-in-left';

            // --- Animation using CSS classes ---
            const handleOutAnimationEnd = (event) => {
                 // Ensure the event is for the correct animation
                 if (event.animationName !== outClass.split(' ')[0]) return;
                 // event.target.removeEventListener('animationend', handleOutAnimationEnd); // No need to remove with {once: true}
                 event.target.classList.remove(outClass);
                 updateImageElement(newSrc); // Update the image source *after* old one slides out

                 // Trigger the slide-in animation
                 requestAnimationFrame(() => { // Use rAF for timing
                      event.target.classList.add(inClass);
                      event.target.addEventListener('animationend', function handleInAnimationEnd(eventInner) {
                           if (eventInner.animationName !== inClass.split(' ')[0]) return;
                          // eventInner.target.removeEventListener('animationend', handleInAnimationEnd);
                           eventInner.target.classList.remove(inClass);
                      }, { once: true });
                 });
            };

            // Add the listener before adding the class
             DOMElements.imageContainer.addEventListener('animationend', handleOutAnimationEnd, { once: true });
             // Use rAF to ensure the class is added in the next frame, allowing transition setup
             requestAnimationFrame(() => {
                 DOMElements.imageContainer.classList.add(outClass);
             });

        } else {
            // No animation needed or first load, just update the image directly
            updateImageElement(newSrc);
        }
    }

    function updateTextDetails(itemData) {
        if (!DOMElements.menuNameElement || !DOMElements.menuDescriptionElement) return;
        DOMElements.menuNameElement.textContent = itemData?.name || 'ชื่อเมนู';
        DOMElements.menuDescriptionElement.textContent = itemData?.description || 'ไม่มีคำอธิบาย';
    }

    function updatePriceDetails(prices) {
         if (!DOMElements.menuPriceContainer || !DOMElements.priceElementsCache) return;
         const displayOrder = ['Small', 'Normal', 'Extra', 'Family'];
         let firstVisibleFound = false;

          // Hide all price items and their preceding separators initially
          displayOrder.forEach(size => {
              const cache = DOMElements.priceElementsCache[size];
              cache?.parentSpan?.classList.add('hidden');
              if(cache?.separator) cache.separator.classList.add('hidden');
          });

          // Show items with valid prices and update their content
         displayOrder.forEach((size) => {
             const cache = DOMElements.priceElementsCache[size];
             const priceValue = prices?.[size]; // Use optional chaining

             if (cache?.parentSpan && priceValue !== null && priceValue !== undefined && !isNaN(priceValue)) {
                 cache.value.textContent = formatPrice(priceValue);
                 cache.parentSpan.classList.remove('hidden');
                 // Update aria-label for accessibility
                 const labelText = cache.label?.textContent || size; // Get text label or use size name
                  const itemName = DOMElements.menuNameElement?.textContent || ''; // Get current item name
                 cache.button?.setAttribute('aria-label', `เพิ่ม ${itemName} ${labelText} ${formatPrice(priceValue)} ลงตระกร้า`);

                 // Show separator *before* this item if it's not the first one visible
                 if (firstVisibleFound && cache.separator) {
                    cache.separator.classList.remove('hidden');
                 }
                 firstVisibleFound = true; // Mark that at least one visible item has been found
             }
         });
     }

    function showItemDetails(index, direction = 'none') {
        if (!DOMElements.menuDetailsContainer) { console.error("Missing menu details container."); return; }

        const isValidIndex = index >= 0 && index < currentFilteredItems.length;

        if (!isValidIndex || currentFilteredItems.length === 0) {
            // Hide details and clear image if no valid item to show
            DOMElements.menuDetailsContainer.style.display = 'none';
            updateImageWithAnimation(null, ''); // Clear image using the function
            updateTextDetails({}); // Clear text
            updatePriceDetails({}); // Clear prices
            currentDisplayedItemId = null;
            currentDisplayIndex = -1;
            console.log("Hiding details: No item to display or index out of bounds.");
            return;
        }

        currentDisplayIndex = index;
        const itemData = currentFilteredItems[currentDisplayIndex];
         if (!itemData) { // Double-check, though isValidIndex should prevent this
             console.error("Item data unexpectedly missing at index:", index);
              DOMElements.menuDetailsContainer.style.display = 'none';
             return;
         }
        currentDisplayedItemId = itemData.id;

        // Determine the image source, prefer dataImageSrc, fallback to src, then null
        const newImageSrc = itemData.dataImageSrc || itemData.src || null;

        // --- เพิ่ม Log ตรงนี้ ---
        console.log('Showing Item:', itemData.id, itemData.name); // แสดง ID และชื่อรายการปัจจุบัน
        console.log('Main Image URL for Item:', newImageSrc);     // แสดง URL รูปใหญ่ที่พยายามจะโหลด
        console.log('Item Prices:', itemData.prices);             // แสดง Object ราคาที่ได้รับ
        // ----------------------

        // Call decomposed update functions
        updateImageWithAnimation(newImageSrc, itemData.alt || itemData.name, direction);
        updateTextDetails(itemData);
        updatePriceDetails(itemData.prices);

        // Ensure the details container is visible
        DOMElements.menuDetailsContainer.style.display = 'block';
    }


    // --- Rendering: Menu Grid Items ---
    function displayMenuItems(category) {
        if (!DOMElements.bottomMenuContainer) { console.error("Bottom menu container not found."); return; }
        DOMElements.bottomMenuContainer.innerHTML = ''; // Clear previous items
        currentCategory = category;

        if (!menuData || menuData.length === 0) {
            // Handle case where menu data hasn't loaded or is empty
            console.warn("menuData is empty, cannot display items for category:", category);
            DOMElements.bottomMenuContainer.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary); grid-column: 1 / -1;">ไม่มีข้อมูลเมนูในขณะนี้</p>';
            // Ensure details of previous category are hidden
            showItemDetails(-1); // Call with invalid index to hide details
            currentFilteredItems = []; // Reset filtered items
            return;
        }

        // Filter items for the selected category
        currentFilteredItems = menuData.filter(item => Array.isArray(item.category) && item.category.includes(category));

        if (currentFilteredItems.length === 0) {
             // Handle case where category has no items
             const safeCategoryName = category?.replace(/</g, "&lt;") || 'นี้';
             DOMElements.bottomMenuContainer.innerHTML = `<p style="text-align: center; color: var(--color-text-secondary); grid-column: 1 / -1;">ไม่มีเมนูในหมวดหมู่ "${safeCategoryName}"</p>`;
             showItemDetails(-1); // Hide details area
             return;
        }

        // Build menu items using a DocumentFragment for performance
        const fragment = document.createDocumentFragment();
        currentFilteredItems.forEach((item, index) => {
            const menuItemDiv = document.createElement('div');
            menuItemDiv.classList.add('menu-item');
            menuItemDiv.dataset.itemId = item.id;
            menuItemDiv.dataset.index = index; // Store index for click handler
            menuItemDiv.setAttribute('role', 'button');
            menuItemDiv.setAttribute('tabindex', '0'); // Make focusable

            const img = document.createElement('img');
            const imgSrc = item.src || CONFIG.PLACEHOLDER_IMAGE; // Use placeholder if src is missing
            img.src = imgSrc;
            img.alt = item.alt || item.name || 'รูปภาพเมนู'; // Provide meaningful alt text
            img.loading = 'lazy'; // Defer loading off-screen images
             // Add error handler for thumbnail images
             img.onerror = function() {
                 console.warn("Thumbnail image failed to load:", imgSrc);
                 this.onerror = null; // Prevent potential infinite loop if placeholder fails
                 this.src = CONFIG.PLACEHOLDER_IMAGE;
                 this.alt = `${item.name || 'Menu item'} (Image unavailable)`;
            };

            menuItemDiv.appendChild(img);
            // Add event listeners for click and keyboard interaction
            menuItemDiv.addEventListener('click', handleMenuItemClick);
            menuItemDiv.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleMenuItemClick(e); });

            fragment.appendChild(menuItemDiv);
        });
        // Append all items at once to the DOM
        DOMElements.bottomMenuContainer.appendChild(fragment);

        // Show details of the first item in the filtered list
        showItemDetails(0);
    }

    function handleMenuItemClick(event) {
        // Ensure the click/keydown happened on the intended target element
        const menuItemDiv = event.currentTarget;
        if (!menuItemDiv || !menuItemDiv.dataset.index) return;

        const clickedIndex = parseInt(menuItemDiv.dataset.index, 10);

        // Check if the index is valid within the currently filtered items
        if (!isNaN(clickedIndex) && clickedIndex >= 0 && clickedIndex < currentFilteredItems.length) {
            showItemDetails(clickedIndex);
            // Scroll smoothly to the top after a short delay
            // This allows the browser time to render the details before scrolling
            setTimeout(() => {
                // Check if menuDetailsContainer exists and is visible before scrolling
                 if (DOMElements.menuDetailsContainer && DOMElements.menuDetailsContainer.style.display !== 'none') {
                     // Option 1: Scroll container into view (if details are below fold)
                     // DOMElements.menuDetailsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                     // Option 2: Scroll window to top (if details are always near top)
                     window.scrollTo({ top: 0, behavior: 'smooth' });
                 }
            }, 100); // Adjust delay if needed (e.g., 50-150ms)
        } else {
            console.error("Invalid index on menu item click:", menuItemDiv.dataset.index, "Current Filtered Length:", currentFilteredItems.length);
        }
    }

    // --- Rendering: Category Bar ---
    function populateCategoryBar() {
        const container = DOMElements.categoryBarContainer;
        if (!container) { console.warn("Category bar container not found."); return; }

        if (!allCategories || allCategories.length === 0) {
             // Handle case where no categories were loaded
             container.innerHTML = '<p style="color: var(--color-text-secondary); padding: 10px;">ไม่มีหมวดหมู่</p>';
            return;
        }

        container.innerHTML = ''; // Clear loading/error message
        const fragment = document.createDocumentFragment();
        allCategories.forEach((category, index) => { // Add index for managing tabindex
            const categoryDiv = document.createElement('div');
            categoryDiv.classList.add('category-item');
            categoryDiv.dataset.category = category;
            categoryDiv.setAttribute('role', 'tab');
            // Set tabindex: 0 for the first item, -1 for others initially
            categoryDiv.setAttribute('tabindex', index === 0 ? '0' : '-1');
             categoryDiv.setAttribute('aria-selected', 'false');


            const iconClass = CONFIG.CATEGORY_ICONS[category] || CONFIG.CATEGORY_ICONS["default"];
            // Sanitize category name for display
            const safeCategoryName = category?.replace(/</g, "&lt;")?.replace(/>/g, "&gt;") || 'N/A';
            categoryDiv.innerHTML = `
                <i class="${iconClass}" aria-hidden="true"></i>
                <span>${safeCategoryName}</span>
            `;

            categoryDiv.addEventListener('click', handleCategoryClick);
            // Add keydown listener for better keyboard navigation (optional but recommended)
            // categoryDiv.addEventListener('keydown', handleCategoryKeydown);
            fragment.appendChild(categoryDiv);
        });
        container.appendChild(fragment);
    }

    function handleCategoryClick(event) {
         const clickedItem = event.currentTarget;
         // Prevent processing if the item is already selected
         if (clickedItem.classList.contains('selected')) {
             return;
         }

         const selectedCategory = clickedItem.dataset.category;

         // Update visual selection and ARIA states
         const allCategoryItems = DOMElements.categoryBarContainer.querySelectorAll('.category-item');
         allCategoryItems.forEach(cat => {
             cat.classList.remove('selected');
             cat.setAttribute('aria-selected', 'false');
             cat.setAttribute('tabindex', '-1'); // Make non-selected items not directly tabbable
         });
         clickedItem.classList.add('selected');
         clickedItem.setAttribute('aria-selected', 'true');
         clickedItem.setAttribute('tabindex', '0'); // Make selected item tabbable
         // Optionally move focus, though click usually handles this. For keyboard nav, focus is important.
         // clickedItem.focus();

         // Update the displayed menu items for the newly selected category
         displayMenuItems(selectedCategory);
     }

    // ========================================================================
    // ACTION HANDLERS (Using Backend API)
    // ========================================================================
    async function handleCallStaff() {
        // Prevent action if already loading or no table selected
        if (isApiLoading.callStaff) { console.log("Call staff action already in progress."); return; }
        if (!selectedTableNumber) {
            alert('⚠️ กรุณาเลือกหมายเลขโต๊ะก่อนค่ะ');
            openTableSelectModal(); // Prompt user to select table
            return;
        }

        setLoadingState('icon', 'callStaff', true); // Set loading state (disables button)
        const payload = { tableNumber: selectedTableNumber };
        const result = await callBackendApi('callStaff', payload); // Call backend
        setLoadingState('icon', 'callStaff', false); // Reset loading state

         if (result.success) {
             alert('✅ เรียกพนักงานบริการให้เรียบร้อยค่ะ กรุณารอสักครู่ 💁‍♀️');
         }
         // Specific error messages (like network error, server error) are handled within callBackendApi
    }

    async function handleOrderSubmission() {
         // Prevent action if already loading, cart empty, or no table selected
         if (isApiLoading.order) { console.log("Order submission already in progress."); return; }
         if (cartItems.length === 0) { alert('ตระกร้าสินค้าของคุณว่างเปล่า'); return; }
         if (!selectedTableNumber) { alert('⚠️ กรุณาเลือกหมายเลขโต๊ะก่อนสั่งอาหารค่ะ'); openTableSelectModal(); return; }

         setLoadingState('button', 'order', true); // Set loading state

         // Prepare payload with only necessary data
         const orderPayload = {
             tableNumber: selectedTableNumber,
             items: cartItems.map(item => ({
                 name: item.name,
                 size: item.size,
                 quantity: item.quantity,
                 price: item.price,
                 id: item.id // Include ID if needed by backend/logging
             }))
         };

         const result = await callBackendApi('submitOrder', orderPayload); // Call backend

         if (result.success) {
             // Action successful: Provide feedback, update state, UI
             alert(`ส่งรายการสั่งซื้อจาก ${CONFIG.TABLE_NUMBER_PREFIX}${selectedTableNumber} สำเร็จ!`);

             // Move items from cart to ordered list
             cartItems.forEach(cartItem => {
                 const existingIndex = orderedItems.findIndex(orderedItem => orderedItem.cartId === cartItem.cartId);
                 if (existingIndex > -1) {
                     // Item already exists in ordered list, increase quantity
                     orderedItems[existingIndex].quantity += cartItem.quantity;
                 } else {
                     // Add new item to ordered list
                     orderedItems.push({ ...cartItem });
                 }
             });
             cartItems = []; // Clear the cart

             // Update local storage and UI
             saveCartToLocalStorage();
             saveOrderedItemsToLocalStorage();
             renderCart();
             updateCartIcon();
             renderOrderedItems();
             updateMyFoodIcon();
             if (DOMElements.cartPopup?.classList.contains('open')) {
                  DOMElements.cartPopup.classList.remove('open'); // Close cart popup
                  DOMElements.cartIcon.setAttribute('aria-expanded', 'false');
             }


             // Give feedback animation on My Food icon
             DOMElements.myFoodIcon?.classList.add('updated');
             setTimeout(() => { DOMElements.myFoodIcon?.classList.remove('updated'); }, CONFIG.ANIMATION_SPEED_MS + 50);

         } else {
             // Action failed: callBackendApi already showed an alert.
             // Log the specific failure message from backend if available.
             console.error("Order submission failed:", result.message);
         }

         // Reset loading state regardless of success/failure AFTER processing
         setLoadingState('button', 'order', false);
    }

    async function handleCheckout() {
         // Prevent action if already loading, no ordered items, or no table selected
         if (isApiLoading.checkout) { console.log("Checkout action already in progress."); return; }
         if (orderedItems.length === 0) { alert('ยังไม่มีรายการอาหารที่สั่งสำหรับชำระเงิน'); return; }
         if (!selectedTableNumber) { alert('⚠️ กรุณาเลือกหมายเลขโต๊ะก่อนเรียกชำระเงินค่ะ'); openTableSelectModal(); return; }

         setLoadingState('button', 'checkout', true); // Set loading state

          // Prepare payload for checkout call
         const checkoutPayload = {
             tableNumber: selectedTableNumber,
             orderedItems: orderedItems.map(item => ({ // Send ordered items for confirmation/logging
                 name: item.name,
                 size: item.size,
                 quantity: item.quantity,
                 price: item.price
             }))
         };

         const result = await callBackendApi('checkout', checkoutPayload); // Call backend

         // *** THIS IS THE CORRECTED LINE ***
         if (result.success) { // Check the 'success' property of the result object
             // Action successful: Provide feedback, potentially update UI
             alert(`✅ เรียกพนักงานเพื่อชำระเงินสำหรับ ${CONFIG.TABLE_NUMBER_PREFIX}${selectedTableNumber} เรียบร้อยแล้วค่ะ`);

             // Optional: Clear orderedItems locally after successful call? Decide based on workflow.
             // orderedItems = [];
             // saveOrderedItemsToLocalStorage();
             // renderOrderedItems(); // Update UI if cleared
             // updateMyFoodIcon();   // Update badge if cleared

             // Close the popup
             if (DOMElements.myFoodPopup?.classList.contains('open')) {
                  DOMElements.myFoodPopup.classList.remove('open');
                   DOMElements.myFoodIcon.setAttribute('aria-expanded', 'false');
             }
         } else {
              // Action failed: callBackendApi already showed an alert.
             console.error("Checkout call failed:", result.message);
         }

         // Reset loading state regardless of success/failure AFTER processing
         setLoadingState('button', 'checkout', false);
    }

    // ========================================================================
    // EVENT LISTENERS SETUP
    // ========================================================================
    function setupEventListeners() {
        console.log("Setting up event listeners...");

        // --- Table Selection ---
        DOMElements.tableNumberDisplay?.addEventListener('click', openTableSelectModal);
        DOMElements.tableSelectCloseBtn?.addEventListener('click', closeTableSelectModal);
        DOMElements.tableSelectModal?.addEventListener('click', (e) => {
            // Close modal if backdrop is clicked
             if (e.target === DOMElements.tableSelectModal) closeTableSelectModal();
        });
        // Close modal on Escape key press when modal is open
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && DOMElements.tableSelectModal?.classList.contains('open')) {
                closeTableSelectModal();
            }
         });
        DOMElements.tablePromptNotification?.addEventListener('click', hideTablePromptNotification);
        DOMElements.tablePromptNotification?.addEventListener('touchstart', hideTablePromptNotification, { passive: true });

        // --- Add to Cart (Delegated from Price Container) ---
         DOMElements.menuPriceContainer?.addEventListener('click', (e) => {
             // Find the closest button element that matches the selector
             const button = e.target.closest('.add-to-cart-button');
             if (button) { // If a button was clicked (or its child icon)
                 const size = button.dataset.size;
                 // Ensure we have a currently displayed item ID and a valid size from the button
                 if (currentDisplayedItemId && size) {
                     addToCart(currentDisplayedItemId, size);
                 } else { console.warn("Cannot add to cart. Missing item ID or size.", { currentDisplayedItemId, size }); }
             }
         });

        // --- Category Bar (Listeners added dynamically in populateCategoryBar/handleCategoryClick) ---
        // Event listeners for category items are added when they are created in populateCategoryBar

        // --- Cart Popup Toggle ---
        DOMElements.cartIcon?.addEventListener('click', () => {
            const isCurrentlyOpen = DOMElements.cartPopup?.classList.contains('open');
            // Close MyFood if open
            if (DOMElements.myFoodPopup?.classList.contains('open')) {
                DOMElements.myFoodPopup.classList.remove('open');
                 DOMElements.myFoodIcon?.setAttribute('aria-expanded', 'false');
            }
            // Toggle Cart
            const isOpen = DOMElements.cartPopup?.classList.toggle('open');
            DOMElements.cartIcon?.setAttribute('aria-expanded', String(isOpen)); // Set aria-expanded state
            if (isOpen) {
                 renderCart(); // Re-render cart content when opening
                 // Optional: Focus on the close button or the list inside
                 DOMElements.cartCloseBtn?.focus();
            }
        });
        // Cart Close Button
        DOMElements.cartCloseBtn?.addEventListener('click', () => {
            DOMElements.cartPopup?.classList.remove('open');
            DOMElements.cartIcon?.setAttribute('aria-expanded', 'false');
             DOMElements.cartIcon?.focus(); // Return focus to the icon
        });

        // --- My Food Popup Toggle ---
        DOMElements.myFoodIcon?.addEventListener('click', () => {
            const isCurrentlyOpen = DOMElements.myFoodPopup?.classList.contains('open');
            // Close Cart if open
            if (DOMElements.cartPopup?.classList.contains('open')) {
                 DOMElements.cartPopup.classList.remove('open');
                 DOMElements.cartIcon?.setAttribute('aria-expanded', 'false');
            }
            // Toggle MyFood
            const isOpen = DOMElements.myFoodPopup?.classList.toggle('open');
             DOMElements.myFoodIcon?.setAttribute('aria-expanded', String(isOpen));
            if (isOpen) {
                 renderOrderedItems(); // Re-render ordered items when opening
                 DOMElements.myFoodCloseBtn?.focus(); // Focus close button
            }
        });
         // My Food Close Button
        DOMElements.myFoodCloseBtn?.addEventListener('click', () => {
             DOMElements.myFoodPopup?.classList.remove('open');
             DOMElements.myFoodIcon?.setAttribute('aria-expanded', 'false');
             DOMElements.myFoodIcon?.focus(); // Return focus
        });

        // --- Action Buttons ---
        DOMElements.callStaffIcon?.addEventListener('click', handleCallStaff);
        DOMElements.orderButton?.addEventListener('click', handleOrderSubmission);
        DOMElements.myFoodCheckoutButton?.addEventListener('click', handleCheckout);

        // --- Image Swipe Gestures ---
        setupSwipeListeners();

        console.log("Event listeners setup complete.");
    }

    // --- Swipe Logic ---
    function setupSwipeListeners() {
        if (!DOMElements.imageContainer) return;

        let touchStartX = 0;
        let touchEndX = 0;
        let isSwiping = false;
        let isDragging = false;
        let dragStartX = 0;

        // Touch Events
        DOMElements.imageContainer.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1) { // Start swipe only with one finger
                 touchStartX = e.touches[0].clientX;
                 isSwiping = true;
             }
        }, { passive: true }); // Use passive listener if not preventing default scroll

        DOMElements.imageContainer.addEventListener('touchmove', (e) => {
             if (isSwiping && e.touches.length === 1) {
                 touchEndX = e.touches[0].clientX;
             }
        }, { passive: true });

        DOMElements.imageContainer.addEventListener('touchend', (e) => {
            // Check if swipe was actually in progress and ended with one finger
            if (!isSwiping || e.changedTouches.length !== 1) {
                isSwiping = false; // Reset flag if touch cancel or multiple fingers
                return;
            }
            // Use the final position from changedTouches
            touchEndX = e.changedTouches[0].clientX;
            handleSwipeAction(touchStartX, touchEndX); // Process the swipe
            // Reset swipe state
            isSwiping = false;
            touchStartX = 0;
            touchEndX = 0;
        });

        // Mouse Drag Events (for Desktop)
        DOMElements.imageContainer.addEventListener('mousedown', (e) => {
            // Prevent starting drag if it's not the primary mouse button
            if (e.button !== 0) return;
            isDragging = true;
            dragStartX = e.clientX;
            DOMElements.imageContainer.style.cursor = 'grabbing'; // Visual feedback
            e.preventDefault(); // Prevent text selection/image dragging default behavior
        });

        // Listen on the document to catch mouse movements and mouse up events
        // even if the cursor leaves the image container during the drag.
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            // Optional: Add visual feedback during drag (e.g., move image slightly)
        });

        document.addEventListener('mouseup', (e) => {
            if (!isDragging || e.button !== 0) return; // Ensure it's the primary button release
            isDragging = false;
            const dragEndX = e.clientX;
            DOMElements.imageContainer.style.cursor = 'grab'; // Restore cursor
            handleSwipeAction(dragStartX, dragEndX); // Process the drag as a swipe
            dragStartX = 0;
        });

         // Handle case where mouse leaves the window while dragging (less common, but good practice)
         document.addEventListener('mouseleave', (e) => {
             // Check if mouse leaves the viewport while dragging
             if (isDragging && !e.relatedTarget && !e.toElement) {
                 isDragging = false;
                 DOMElements.imageContainer.style.cursor = 'grab';
                 // Optional: Decide whether to complete or cancel swipe on mouseleave
                 // handleSwipeAction(dragStartX, e.clientX); // Or just reset dragStartX = 0;
                 dragStartX = 0;
             }
         });
    }

    // Processes the swipe/drag action based on distance moved
    function handleSwipeAction(startX, endX) {
        const deltaX = endX - startX;
        // Only trigger action if swipe distance exceeds threshold
        if (Math.abs(deltaX) > CONFIG.SWIPE_THRESHOLD_PX) {
            if (deltaX > 0) { // Swipe Right (Show Previous Item)
                showPreviousItem();
            } else { // Swipe Left (Show Next Item)
                showNextItem();
            }
        }
    }

    // Navigate to the previous item in the current filtered list
    function showPreviousItem() {
        // Ensure there are items to navigate and the index is valid
        if (currentFilteredItems.length <= 1 || currentDisplayIndex < 0) return;
        // Calculate the new index, wrapping around to the end if at the beginning
        let newIndex = (currentDisplayIndex - 1 + currentFilteredItems.length) % currentFilteredItems.length;
        showItemDetails(newIndex, 'prev'); // Show details with 'prev' direction for animation
    }

    // Navigate to the next item in the current filtered list
    function showNextItem() {
        // Ensure there are items to navigate and the index is valid
        if (currentFilteredItems.length <= 1 || currentDisplayIndex < 0) return;
         // Calculate the new index, wrapping around to the beginning if at the end
        let newIndex = (currentDisplayIndex + 1) % currentFilteredItems.length;
        showItemDetails(newIndex, 'next'); // Show details with 'next' direction for animation
    }


    // ========================================================================
    // INITIALIZATION
    // ========================================================================
    async function initializeApp() {
        console.log("DOM Content Loaded. Initializing App...");

         // 0. Cache essential DOM elements & Setup Price Element Cache
         // Ensure this runs after the DOM is fully available
         setupPriceElementCache();

        // 1. Load table number preference from local storage
        selectedTableNumber = loadSelectedTable();
        updateTableDisplay(selectedTableNumber); // Update UI with loaded or default state
        populateTableList(CONFIG.MAX_TABLE_NUMBER); // Create the table selection list
        // Show prompt only if no table number is loaded/valid
        if (!selectedTableNumber) {
            showTablePromptNotification();
        } else {
            document.title = `เมนูอาหาร - ${CONFIG.TABLE_NUMBER_PREFIX}${selectedTableNumber}`; // Set title if table known
        }

        // 2. Load cart and ordered items state from local storage
        loadCartFromLocalStorage();
        loadOrderedItemsFromLocalStorage();
        // Render initial UI based on loaded state *before* fetching new data
        renderCart();
        updateCartIcon();
        renderOrderedItems();
        updateMyFoodIcon();

        // 3. Fetch menu data from the backend (Google Apps Script)
        const dataLoaded = await fetchMenuData(); // This function now handles loading indicators and errors
        
        // 4. Populate dynamic content (categories, initial menu) only if data fetch was successful
        if (dataLoaded) {
            console.log('Categories Received:', allCategories);
            populateCategoryBar(); // สร้าง category buttons

             // Select and display the first category's items automatically
             const firstCategoryElement = DOMElements.categoryBarContainer?.querySelector('.category-item');
             if (firstCategoryElement) {
                 // Simulate a click on the first category to trigger selection and display
                  handleCategoryClick({ currentTarget: firstCategoryElement });
             } else if (allCategories.length === 0) {
                  // Handle case where data loaded but no categories were returned
                  console.warn("Data loaded, but no categories found.");
                  if(DOMElements.bottomMenuContainer) DOMElements.bottomMenuContainer.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary); grid-column: 1 / -1;">ไม่มีเมนูให้แสดง</p>';
                  showItemDetails(-1); // Hide details section
             }
        } else {
            // fetchMenuData already displayed an error message in the category/menu area
            // Ensure details section is also hidden if data fetch failed
            showItemDetails(-1); // Hide details section
        }

        // 5. Setup all general event listeners (for popups, action buttons, etc.)
        // This should run regardless of data fetch success to ensure basic UI interaction works
        setupEventListeners();

        console.log("App Initialization complete.");
    }

    // --- Start the application once the DOM is fully loaded ---
    // Using DOMContentLoaded is generally preferred and safer than load
    if (document.readyState === 'loading') { // Handle cases where script runs before DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else { // Handle cases where script runs after DOMContentLoaded
        initializeApp();
    }

</script>
</body>
</html>
